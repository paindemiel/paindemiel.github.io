---
layout: post
title: Malware Analysis 04 - Dynamic Debugging Analysis
category : [MalwareAnalysis]
tags: reverse
---

## Debugging Tools Overview

### Windows PE Debuggers

#### x64dbg
x64dbg is a powerful open-source debugger for Windows that supports both 32-bit and 64-bit applications.

**Key Features:**
- User-friendly interface with multiple views (disassembly, registers, memory, stack)
- Plugin architecture for extensibility
- Scripting support with Python
- Built-in API breakpoint functionality
- Memory map and process information

**Common Commands:**
```assembly
bp kernel32.dll!CreateFileA    ; Set breakpoint on CreateFileA
bl                            ; List breakpoints
bc 1                          ; Clear breakpoint 1
g                             ; Continue execution
s                             ; Step into
n                             ; Step over
```

#### x32dbg
x32dbg is the 32-bit version of x64dbg, specifically designed for debugging 32-bit applications.

**Advantages:**
- Optimized for 32-bit applications
- Better compatibility with legacy malware
- Smaller memory footprint
- Faster execution on 32-bit systems

#### OllyDbg
OllyDbg is a classic 32-bit assembler-level debugger that has been widely used in the security community.

**Features:**
- Intuitive interface with multiple windows
- Built-in disassembler
- Plugin support
- Memory dump capabilities
- Import/Export table analysis

### Linux ELF Debuggers

#### GDB (GNU Debugger)
GDB is the standard debugger for Linux systems and is highly effective for analyzing ELF files.

**Basic Commands:**
```bash
gdb ./malware_sample
(gdb) break main
(gdb) run
(gdb) info registers
(gdb) x/10i $eip
(gdb) stepi
(gdb) nexti
(gdb) continue
```

**Advanced GDB Techniques:**
```bash
# Set breakpoint on specific function
(gdb) break *0x08048400

# Examine memory at specific address
(gdb) x/20x 0x08048400

# Follow execution flow
(gdb) set follow-fork-mode child

# Attach to running process
gdb -p <pid>
```

**GDB Scripts for Automation:**
```python
# gdb_script.py
import gdb

class MalwareAnalyzer(gdb.Command):
    def __init__(self):
        super(MalwareAnalyzer, self).__init__("malware_analyze", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        # Set breakpoints on common API calls
        gdb.execute("break *malloc")
        gdb.execute("break *free")
        gdb.execute("break *execve")
        gdb.execute("run")

MalwareAnalyzer()
```

## Anti-Debugger Techniques and Evasion

### Common Anti-Debugger Methods

#### 1. IsDebuggerPresent API
```c
#include <windows.h>

BOOL CheckDebugger() {
    return IsDebuggerPresent();
}
```

#### 2. PEB (Process Environment Block) Checks
```c
BOOL CheckPEBDebugger() {
    __asm {
        mov eax, fs:[0x30]    ; PEB address
        mov eax, [eax + 0x02] ; BeingDebugged flag
        test eax, eax
        jnz debugger_detected
    }
}
```

#### 3. Timing Checks
```c
BOOL CheckTiming() {
    DWORD start = GetTickCount();
    __asm int 3              ; Software breakpoint
    DWORD end = GetTickCount();
    return (end - start) > 1000; // If execution takes too long
}
```

#### 4. Hardware Breakpoint Detection
```c
BOOL CheckHardwareBreakpoints() {
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
    GetThreadContext(GetCurrentThread(), &ctx);
    
    return (ctx.Dr0 != 0 || ctx.Dr1 != 0 || 
            ctx.Dr2 != 0 || ctx.Dr3 != 0);
}
```

### ScyllaHide: Anti-Debugger Evasion

ScyllaHide is a powerful tool designed to hide debugging activity from malware's anti-debugger detection mechanisms.

#### Installation and Setup
```bash
# Download from: https://github.com/x64dbg/ScyllaHide
# Extract to x64dbg plugins directory
```

#### Key Features:
1. **API Hooking**: Intercepts and modifies anti-debugger API calls
2. **PEB Manipulation**: Modifies PEB flags to hide debugger presence
3. **Timing Protection**: Prevents timing-based detection
4. **Hardware Breakpoint Hiding**: Masks hardware breakpoint registers

#### Configuration Options:
```ini
[ScyllaHide]
# Hide from IsDebuggerPresent
HideFromPeb = true

# Hide from NtQueryInformationProcess
HideFromNtQueryInformationProcess = true

# Prevent timing detection
PreventTimingDetection = true

# Hide hardware breakpoints
HideFromHardwareBreakpoints = true
```

#### Advanced ScyllaHide Techniques:

**Custom API Hooking:**
```c
// Hook IsDebuggerPresent to always return FALSE
BOOL WINAPI HookedIsDebuggerPresent() {
    return FALSE;
}
```

**PEB Structure Modification:**
```c
// Modify BeingDebugged flag in PEB
void HideFromPEB() {
    PPEB pPeb = (PPEB)__readfsdword(0x30);
    pPeb->BeingDebugged = FALSE;
}
```

## Practical Debugging Scenarios

### Scenario 1: Analyzing Packed Malware

**Tools Used:** x64dbg, ScyllaHide

**Steps:**
1. Load the packed executable in x64dbg
2. Enable ScyllaHide anti-detection features
3. Set breakpoint on common unpacking routines:
   ```assembly
   bp VirtualAlloc
   bp VirtualProtect
   bp WriteProcessMemory
   ```
4. Run the malware and observe unpacking behavior
5. Dump the unpacked code from memory

### Scenario 2: Analyzing Linux ELF Malware

**Tools Used:** GDB, strace, ltrace

**Steps:**
```bash
# Basic dynamic analysis
strace -f ./malware_sample
ltrace -f ./malware_sample

# GDB analysis
gdb ./malware_sample
(gdb) set disassembly-flavor intel
(gdb) break main
(gdb) run
(gdb) info proc mappings
(gdb) dump memory dump.bin 0x08048000 0x08049000
```

### Scenario 3: Bypassing Anti-Debugger Protection

**Challenge:** Malware that detects debugger presence and exits

**Solution:**
1. Use ScyllaHide with all protection features enabled
2. Set breakpoints before anti-debugger checks
3. Modify return values of detection functions
4. Use hardware breakpoints instead of software breakpoints

**Example GDB Script:**
```python
# anti_debug_bypass.py
import gdb

def bypass_anti_debug():
    # Set breakpoint on IsDebuggerPresent
    gdb.execute("break *IsDebuggerPresent")
    gdb.execute("run")
    
    # Modify return value to 0 (no debugger detected)
    gdb.execute("set $eax = 0")
    gdb.execute("continue")

bypass_anti_debug()
```

## Advanced Debugging Techniques

### 1. Conditional Breakpoints
```assembly
; Break only when specific condition is met
bp kernel32.dll!CreateFileA "if (strstr(esp+4, 'config.txt')) { gc }"
```

### 2. Memory Breakpoints
```assembly
; Set breakpoint on memory access
ba r4 0x00401000    ; Read breakpoint on 4 bytes
ba w4 0x00401000    ; Write breakpoint on 4 bytes
```

### 3. API Monitoring
```python
# Monitor specific API calls
apis_to_monitor = [
    "CreateFileA", "CreateFileW",
    "WriteFile", "ReadFile",
    "CreateProcessA", "CreateProcessW",
    "RegCreateKeyA", "RegSetValueA"
]

for api in apis_to_monitor:
    gdb.execute(f"break *{api}")
```

### 4. Process Injection Analysis
```assembly
; Monitor process creation and injection
bp kernel32.dll!CreateProcessA
bp kernel32.dll!WriteProcessMemory
bp kernel32.dll!CreateRemoteThread
```

## Best Practices for Dynamic Debugging

### 1. Environment Isolation
- Use virtual machines for analysis
- Disable network connectivity when possible
- Use snapshots for easy restoration

### 2. Documentation
- Take screenshots of important findings
- Document API calls and their parameters
- Record memory addresses and their contents

### 3. Automation
- Use scripts to automate repetitive tasks
- Create custom GDB/x64dbg scripts for specific malware families
- Implement logging for long-running analysis sessions

### 4. Anti-Detection
- Always use anti-debugger evasion tools
- Monitor for new anti-debugger techniques
- Keep tools updated with latest evasion methods

## Conclusion

Dynamic debugging analysis is an essential skill for malware analysts. By mastering tools like x64dbg, x32dbg, OllyDbg, and GDB, combined with anti-debugger evasion techniques using ScyllaHide, analysts can effectively examine malicious code in its natural execution environment.

The key to successful debugging analysis lies in understanding both the tools and the malware's anti-analysis techniques. With practice and the right approach, even heavily obfuscated and protected malware can be analyzed effectively.

Remember to always work in isolated environments and keep your analysis tools updated with the latest anti-detection capabilities.

## Resources

- [x64dbg Documentation](https://x64dbg.readthedocs.io/)
- [GDB User Manual](https://sourceware.org/gdb/current/onlinedocs/gdb/)
- [ScyllaHide GitHub](https://github.com/x64dbg/ScyllaHide)
- [OllyDbg Tutorial](http://www.ollydbg.de/)
- [PEB Structure Documentation](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

---