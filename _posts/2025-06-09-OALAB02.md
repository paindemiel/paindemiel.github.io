---
layout: post
title: 2 OALAB CFGF
category : [Reverse, OALAB]
tags: reverse
---

# What's the goal of the CFGF process

The main goal here is to make more difficult the analysis of the control flow and overall the analysis of a binary. At first it was used for ransomware because if analyst can understand what's the malware is doing they may find vulnerabilities in the encryption process. However nowadays it can be use on every malware...

# Analysis of the effect on the code and the disassembly


## In theory 

So at the beginning we have a clean control flow, maybe an if else where if the if condition is evaluate to true the control flow goes to b else it goes to c and finally it goes to d.

After control flow graph flattening, all the [basic black](https://en.wikipedia.org/wiki/Basic_block) goes in the dispatcher (in reality the dispatcher is represented by a lot of basic block but it's the concept)

![cfgf1](/assets/images/CFGF/CFGFdraw.png)

## In practice

Let's use this simple exemple :

```c
#include <stdlib.h>
int main(int argc, char** argv) {
  int a = atoi(argv[1]);
  if(a == 0)
    return 1;
  else
    return 10;
  return 0;
}
```

The flattening exemple would be :

```c
#include <stdlib.h>
int main(int argc, char** argv) {
  int a = atoi(argv[1]);
  int b = 0;
  while(1) {
    switch(b) {
      case 0:
        if(a == 0)
          b = 1;
        else
          b = 2;
        break;
      case 1:
        return 1;
      case 2:
        return 10;
      default:
        break;
    }
  }
  return 0;
}
```

So basically all the basic blocks are split, put into an infinite loop and the program flow is now controlled by a `switch` and the variable `b` which define a `state`.

# Tool

[obfuscator-llvm](https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening) - last commit was 8 years ago, it's not really possible to use it anymore ^^ but the code snippet comes from there 

[obfuscator-llvm fork](https://github.com/eshard/obfuscator-llvm) I may test this one