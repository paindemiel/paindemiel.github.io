---
layout: post
title: Malware Analysis 03 - Static Code Analysis
category : [MalwareAnalysis]
tags: reverse
---

## Popular Static Analysis Tools

### IDA

IDA is one of the most powerful and widely used disassemblers in the security industry.

**Key Features:**
- Advanced disassembly and decompilation
- Cross-references and call graphs
- Scripting support (Python, IDC)
- Plugin architecture
- Support for multiple architectures

**Essential Shortcuts:**
- `Space` - Switch between graph and text view
- `N` - Rename variable/function
- `X` - Show cross-references
- `Ctrl+X` - Show cross-references to
- `Ctrl+E` - Export data
- `Alt+T` - Search for text
- `Alt+B` - Search for binary
- `Ctrl+F` - Find in current function
- `F5` - Generate pseudocode (decompilation)
- `Ctrl+Shift+W` - Show strings window
- `Ctrl+Shift+I` - Show imports
- `Ctrl+Shift+E` - Show exports
- `:` - Add comment
- `;` - Add repeatable comment

**Tips:**
- Use the Hex-Rays decompiler for better code understanding
- Leverage the function call graph for control flow analysis
- Utilize IDAPython scripts for automation
- Use the strings window to identify hardcoded strings and URLs

### Radare2

Radare2 is a free, open-source reverse engineering framework with powerful command-line capabilities.

**Key Features:**
- Command-line interface
- Scriptable analysis
- Support for multiple architectures
- Built-in debugger
- Web interface (r2web)
- Decompiler support (r2dec)

**Essential Commands:**
```bash
# Basic analysis
r2 -A <binary>          # Analyze binary
aa                       # Analyze all
afl                      # List functions
axt @sym.main           # Show cross-references
pdf @main               # Disassemble function
pdf @sym.main           # Disassemble function by symbol
s main                  # Seek to main function
s sym.main              # Seek to main symbol
iS                       # Show sections
iM                       # Show modules
iz                       # Show strings
iE                       # Show entry points

# Navigation
s <address>             # Seek to address
s sym.<function>        # Seek to function
s-                      # Go back
s+                      # Go forward
V                       # Enter visual mode
VV                      # Enter graph mode
q                       # Quit

# Analysis
af                      # Analyze function
afn <name> <address>    # Rename function
afvn <old> <new>        # Rename variable
CC <comment>            # Add comment
```

#### r2dec Decompiler

r2dec is a decompiler plugin for Radare2 that converts assembly code back to C-like pseudocode, making it easier to understand the program's logic.

**Installation:**
```bash
# Install r2dec plugin
r2pm init
r2pm install r2dec

# Or install from source
git clone https://github.com/radareorg/r2dec-js
cd r2dec-js
make install
```

**Usage:**
```bash
# Load binary and analyze
r2 -A <binary>

# Decompile current function
pdc

# Decompile specific function
pdc @sym.main

# Decompile with verbose output
pdc -v

# Decompile to file
pdc @sym.main > decompiled.c

# Show decompiled code in visual mode
V
# Then press 'p' to switch to decompiler view
```

**Key r2dec Commands:**
```bash
pdc                    # Decompile current function
pdc @sym.function      # Decompile specific function
pdc -v                 # Verbose decompilation
pdc -a                 # Decompile all functions
pdc -j                 # Output in JSON format
pdc -f                 # Force decompilation even if analysis is incomplete
```

**Decompiler Features:**
- **Variable Recovery**: Automatically identifies and names variables
- **Type Inference**: Attempts to determine data types
- **Control Flow**: Reconstructs if/else statements and loops
- **Function Calls**: Identifies and formats function calls
- **Comments**: Adds explanatory comments for complex operations

**Example Decompilation Output:**
```c
// Original assembly
mov eax, [ebp-0x4]
add eax, 0x1
mov [ebp-0x4], eax
cmp eax, 0xa
jl 0x8048432

// r2dec output
int32_t var_4h = 0;
do {
    var_4h = var_4h + 1;
} while (var_4h < 10);
```

**Configuration:**
```bash
# Set decompiler options
e asm.decompiler = true
e asm.decompiler.verbose = true
e asm.decompiler.raw = false

# Customize output format
e asm.decompiler.indent = 4
e asm.decompiler.comments = true
```

**Advanced Usage:**
```bash
# Decompile with specific architecture
r2 -a x86 -A <binary>
pdc @sym.main

# Decompile in batch mode
r2 -qc "pdc @sym.main" <binary>

# Export all decompiled functions
r2 -qc "afl~[0]" <binary> | while read addr; do
    echo "// Function at $addr" >> all_decompiled.c
    r2 -qc "pdc @$addr" <binary> >> all_decompiled.c
    echo "" >> all_decompiled.c
done
```

**Troubleshooting:**
```bash
# Check if r2dec is installed
r2pm list | grep r2dec

# Reinstall if needed
r2pm uninstall r2dec
r2pm install r2dec

# Update r2dec
r2pm update r2dec

# Check decompiler status
e asm.decompiler
```

### Ghidra

Ghidra is NSA's free reverse engineering tool with advanced decompilation capabilities.

**Key Features:**
- Advanced decompiler
- Collaborative analysis
- Scripting support
- Cross-platform compatibility

**Essential Shortcuts:**
- `D` - Disassemble
- `C` - Create data
- `F` - Create function
- `N` - Rename
- `Ctrl+L` - Show listing
- `Ctrl+G` - Go to address
- `Ctrl+F` - Find
- `Ctrl+Shift+F` - Find references
- `Ctrl+Shift+E` - Show exports
- `Ctrl+Shift+I` - Show imports

### Binary Ninja

Binary Ninja is a modern reverse engineering platform with excellent UI and API.

**Key Features:**
- Modern interface
- Powerful API
- Multiple views (graph, linear, hex)
- Advanced analysis

**Essential Shortcuts:**
- `G` - Go to address
- `N` - Rename
- `X` - Show cross-references
- `C` - Create function
- `D` - Disassemble
- `Ctrl+F` - Find
- `Ctrl+Shift+F` - Find references

### Cutter

Cutter is a GUI for Radare2, providing a user-friendly interface.

**Key Features:**
- Modern GUI
- Graph view
- Decompiler integration
- Cross-platform

**Essential Shortcuts:**
- `Space` - Switch views
- `N` - Rename
- `X` - Cross-references
- `C` - Add comment
- `Ctrl+F` - Find

## Anti-Analysis Detection Techniques

Malware employs sophisticated techniques to detect analysis environments and evade detection. Understanding these methods is crucial for effective static analysis.

### Anti-VM Techniques

#### Method 1: File System Detection
Malware searches for VM-specific files and directories that don't exist on typical host systems.

**VirtualBox Detection:**
```c
#include <windows.h>
#include <stdio.h>

BOOL checkVM() {
    LPCSTR paths[] = {
        "c:\\windows\\system32\\drivers\\VBoxMouse.sys",
        "c:\\windows\\system32\\drivers\\VBoxGuest.sys",
        "c:\\windows\\system32\\drivers\\VBoxSF.sys",
        "c:\\windows\\system32\\drivers\\VBoxVideo.sys",
        "c:\\windows\\system32\\vboxdisp.dll",
        "c:\\windows\\system32\\vboxhook.dll",
        "c:\\windows\\system32\\vboxservice.exe",
        "c:\\windows\\system32\\vboxtray.exe"
    };
    
    for (int i = 0; i < 8; i++) {
        DWORD attributes = GetFileAttributes(paths[i]);
        if (attributes != INVALID_FILE_ATTRIBUTES && 
            !(attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            return TRUE; // VM detected
        }
    }
    return FALSE;
}
```

**VMware Detection:**
```c
LPCSTR vmware_paths[] = {
    "c:\\windows\\system32\\drivers\\vmmouse.sys",
    "c:\\windows\\system32\\drivers\\vmhgfs.sys",
    "c:\\windows\\system32\\drivers\\vmscsi.sys",
    "c:\\program files\\vmware\\vmware tools\\",
    "c:\\program files (x86)\\vmware\\vmware tools\\"
};
```

#### Method 2: Hardware Detection
Virtual environments imitate hardware devices and leave specific traces in device descriptions.

**HDD Vendor Detection:**
```c
#include <windows.h>
#include <winioctl.h>

BOOL checkHardwareVM() {
    STORAGE_PROPERTY_QUERY query;
    query.PropertyId = StorageDeviceProperty;
    query.QueryType = PropertyStandardQuery;
    
    HANDLE hDevice = CreateFile("\\\\.\\PhysicalDrive0", 
                               GENERIC_READ, 
                               FILE_SHARE_READ | FILE_SHARE_WRITE, 
                               NULL, OPEN_EXISTING, 0, NULL);
    
    if (hDevice == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    STORAGE_DESCRIPTOR_HEADER header;
    DWORD bytesReturned = 0;
    
    if (DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, 
                       &query, sizeof(query), &header, 
                       sizeof(header), &bytesReturned, NULL)) {
        
        BYTE* buffer = (BYTE*)malloc(header.Size);
        if (DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, 
                           &query, sizeof(query), buffer, 
                           header.Size, &bytesReturned, NULL)) {
            
            char* vendorId = (char*)(buffer + sizeof(STORAGE_DESCRIPTOR_HEADER));
            // Check for VM-specific vendor IDs like "VMware", "VBox", "QEMU"
            if (strstr(vendorId, "VMware") || strstr(vendorId, "VBox") || 
                strstr(vendorId, "QEMU")) {
                free(buffer);
                CloseHandle(hDevice);
                return TRUE;
            }
        }
        free(buffer);
    }
    CloseHandle(hDevice);
    return FALSE;
}
```

#### Method 3: Registry Detection
Malware examines registry keys for VM-specific artifacts.

```c
BOOL checkVMRegistry() {
    HKEY hKey;
    char value[256];
    DWORD size = sizeof(value);
    
    // Check for VirtualBox registry keys
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        "SYSTEM\\ControlSet001\\Services\\Disk\\Enum", 
        0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        
        if (RegQueryValueEx(hKey, "0", NULL, NULL, 
                           (LPBYTE)value, &size) == ERROR_SUCCESS) {
            if (strstr(value, "VBOX") || strstr(value, "VMware") || 
                strstr(value, "QEMU")) {
                RegCloseKey(hKey);
                return TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    return FALSE;
}
```

#### Method 4: Time-based Sandbox Evasion
Sandboxes often manipulate time to accelerate analysis, which malware can detect.

```c
#include <windows.h>
#include <winternl.h>

typedef NTSTATUS (WINAPI *fnNtDelayExecution)(
    BOOLEAN Alertable,
    PLARGE_INTEGER DelayInterval
);

BOOL checkTimeManipulation() {
    ULONG64 uptimeBefore = GetTickCount64();
    
    HMODULE ntdll = GetModuleHandle("ntdll.dll");
    fnNtDelayExecution myNtDelayExecution = 
        (fnNtDelayExecution)GetProcAddress(ntdll, "NtDelayExecution");
    
    if (!myNtDelayExecution) {
        return FALSE;
    }
    
    LARGE_INTEGER sleepInterval;
    sleepInterval.QuadPart = -10000000; // 1 second
    
    myNtDelayExecution(FALSE, &sleepInterval);
    
    ULONG64 uptimeAfter = GetTickCount64();
    ULONG64 actualSleepTime = uptimeAfter - uptimeBefore;
    
    // If sleep time is significantly less than expected, likely in sandbox
    return (actualSleepTime < 800);
}
```

### Anti-Reverse Engineering Techniques

#### Method 1: Code Obfuscation
Malware uses various techniques to make static analysis difficult.

**Control Flow Obfuscation:**
```c
// Dead code insertion
if (GetTickCount() % 2 == 0) {
    // Real malicious code
    CreateFile("malware.exe", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
} else {
    // Dead code to confuse analysts
    int dummy = 0;
    dummy += 1;
    dummy *= 2;
    dummy -= 1;
}
```

**String Obfuscation:**
```c
// XOR encryption of strings
char encrypted_string[] = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x00}; // "Hello"
char key = 0x41;

void decrypt_string(char* str, char key) {
    for (int i = 0; str[i] != '\0'; i++) {
        str[i] ^= key;
    }
}
```

#### Method 2: Import Obfuscation
Malware hides API calls to evade static detection.

```c
// Dynamic API resolution
HMODULE kernel32 = LoadLibrary("kernel32.dll");
FARPROC createFile = GetProcAddress(kernel32, "CreateFileA");
typedef HANDLE (WINAPI *CreateFileA_t)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
CreateFileA_t CreateFileA_func = (CreateFileA_t)createFile;

// Use the resolved function
HANDLE file = CreateFileA_func("test.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
```

#### Method 3: Self-Modifying Code
Malware modifies its own code at runtime to evade analysis.

```c
void self_modifying_function() {
    DWORD oldProtect;
    VirtualProtect(self_modifying_function, 4096, PAGE_EXECUTE_READWRITE, &oldProtect);
    
    // Modify the function's code
    unsigned char* code = (unsigned char*)self_modifying_function;
    code[0] = 0xC3; // RET instruction
    
    VirtualProtect(self_modifying_function, 4096, oldProtect, &oldProtect);
}
```

### Anti-Debug Techniques

#### Method 1: IsDebuggerPresent() Detection
The most straightforward anti-debugging technique using Windows API.

```c
#include <windows.h>

BOOL checkDebugger() {
    return IsDebuggerPresent();
}

int main() {
    if (checkDebugger()) {
        // Anti-debug code - exit or perform fake behavior
        return 1;
    }
    // Real malicious code
    return 0;
}
```

#### Method 2: CheckRemoteDebuggerPresent() Detection
Detects debuggers attached from different processes.

```c
#include <windows.h>

BOOL checkRemoteDebugger() {
    BOOL isDebugged = FALSE;
    CheckRemoteDebuggerPresent(GetCurrentProcess(), &isDebugged);
    return isDebugged;
}
```

#### Method 3: PEB (Process Environment Block) Checks
Direct examination of the BeingDebugged flag in PEB.

```c
BOOL checkPEBDebugger() {
    __asm {
        mov eax, fs:[0x30]    ; PEB address
        mov al, [eax + 0x02]  ; BeingDebugged flag
        test al, al
        jnz debugger_detected
    }
    return FALSE;
    
debugger_detected:
    return TRUE;
}
```

#### Method 4: NtGlobalFlag Detection
Examines PEB flags set when debugger creates a process.

```c
#include <windows.h>
#include <winternl.h>

#define FLG_HEAP_ENABLE_TAIL_CHECK   0x10
#define FLG_HEAP_ENABLE_FREE_CHECK   0x20
#define FLG_HEAP_VALIDATE_PARAMETERS 0x40
#define NT_GLOBAL_FLAG_DEBUGGED (FLG_HEAP_ENABLE_TAIL_CHECK | \
                                FLG_HEAP_ENABLE_FREE_CHECK | \
                                FLG_HEAP_VALIDATE_PARAMETERS)

BOOL checkNtGlobalFlag() {
    PPEB ppeb = (PPEB)__readgsqword(0x60);
    DWORD ntGlobalFlag = *(PDWORD)((PBYTE)ppeb + 0xBC);
    return (ntGlobalFlag & NT_GLOBAL_FLAG_DEBUGGED) != 0;
}
```

#### Method 5: Hardware Breakpoint Detection
Detects hardware breakpoints set by debuggers.

```c
BOOL checkHardwareBreakpoints() {
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
    GetThreadContext(GetCurrentThread(), &ctx);
    
    return (ctx.Dr0 != 0 || ctx.Dr1 != 0 || 
            ctx.Dr2 != 0 || ctx.Dr3 != 0);
}
```

#### Method 6: Timing-based Anti-Debug
Detects debuggers by measuring execution time.

```c
BOOL checkTimingDebugger() {
    DWORD start = GetTickCount();
    
    // Insert software breakpoint
    __asm int 3
    
    DWORD end = GetTickCount();
    DWORD elapsed = end - start;
    
    // If execution takes too long, likely being debugged
    return (elapsed > 1000);
}
```

#### Method 7: Breakpoint Detection via Memory Analysis
Uses CRC calculations to detect code modifications by debuggers.

```c
DWORD calcCRC(PUCHAR start, PUCHAR end) {
    DWORD crc = 0;
    for (; start < end; ++start) {
        crc += *start;
    }
    return crc;
}

#pragma auto_inline(off)
VOID targetFunction() {
    int calc = 0;
    calc += 2;
    calc <<= 8;
    calc -= 3;
}
VOID targetFunctionEnd() {}
#pragma auto_inline(on)

// Pre-calculated CRC (without breakpoints)
DWORD originalCRC = 0x2bd0;

BOOL checkBreakpointModification() {
    DWORD currentCRC = calcCRC((PUCHAR)targetFunction, (PUCHAR)targetFunctionEnd);
    return (originalCRC != currentCRC);
}
```

**Detection Methods:**
- Monitor API calls to IsDebuggerPresent, CheckRemoteDebuggerPresent
- Check for PEB.BeingDebugged flag
- Look for hardware breakpoint detection
- Monitor timing-based anti-debugging
- Check for debugger-specific strings
- Analyze control flow graphs
- Look for dead code blocks
- Identify string obfuscation patterns
- Check for dynamic imports
- Monitor for self-modifying code
- Monitor registry access
- Check for VM-specific files
- Look for VM process detection
- Analyze hardware fingerprinting
- Monitor for timing-based VM detection

## Dangerous Libraries and APIs

### Windows APIs

**File System:**
```c
CreateFileA/W          // File creation
WriteFile              // File writing
DeleteFileA/W          // File deletion
MoveFileA/W            // File moving
CopyFileA/W            // File copying
```

**Registry:**
```c
RegCreateKeyA/W        // Registry key creation
RegSetValueA/W         // Registry value setting
RegDeleteKeyA/W        // Registry key deletion
```

**Process/Thread:**
```c
CreateProcessA/W       // Process creation
CreateThread           // Thread creation
OpenProcess            // Process access
TerminateProcess       // Process termination
```

**Network:**
```c
socket                 // Socket creation
connect                // Network connection
send/recv              // Data transmission
WSAStartup             // Winsock initialization
```

**System:**
```c
system                 // Command execution
WinExec                // Program execution
ShellExecuteA/W        // Shell execution
```

### Linux APIs

**File System:**
```c
open                   // File opening
write                  // File writing
unlink                 // File deletion
rename                 // File renaming
```

**Process:**
```c
fork                   // Process creation
execve                 // Program execution
kill                   // Process termination
```

**Network:**
```c
socket                 // Socket creation
connect                // Network connection
send/recv              // Data transmission
```

### Suspicious Patterns

**Command Execution:**
```c
// Direct command execution
system("cmd.exe /c whoami");
WinExec("calc.exe", SW_SHOW);

// Indirect command execution
CreateProcess("cmd.exe", "/c net user", ...);
```

**File Operations:**
```c
// Suspicious file paths
CreateFile("C:\\Windows\\System32\\malware.dll", ...);
CreateFile("%TEMP%\\payload.exe", ...);
```

**Registry Modifications:**
```c
// Startup persistence
RegSetValue(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", ...);
```

## Encryption and Packing

### Common Encryption Algorithms

**Symmetric Encryption:**
```c
// AES
// RC4
// DES/3DES
// Blowfish
```

**Asymmetric Encryption:**
```c
// RSA
// DSA
// ECC
```

**Hashing:**
```c
// MD5
// SHA-1
// SHA-256
// SHA-512
```

### Packing Detection

**Common Packers:**
- UPX
- ASPack
- PECompact
- Themida
- VMProtect
- Enigma Protector

**Detection Methods:**
```bash
# Using PEiD or Detect It Easy
# Look for:
- Entropy analysis
- Section characteristics
- Import table characteristics
- Overlay data
- Compression ratios
```

**Unpacking Techniques:**
```bash
# Manual unpacking
# 1. Find OEP (Original Entry Point)
# 2. Dump memory
# 3. Fix imports
# 4. Rebuild PE

# Automated unpacking
# Use tools like:
- Scylla
- ImportREC
- OllyDumpEx
```

### Code Analysis for Encryption

**Key Indicators:**
```c
// Look for:
- Large data arrays (encryption keys)
- XOR operations
- Bit manipulation
- Mathematical operations (modulo, shifts)
- API calls to crypto libraries
```

**Common Patterns:**
```c
// XOR encryption
for (int i = 0; i < data_len; i++) {
    data[i] ^= key[i % key_len];
}

// RC4-like
for (int i = 0; i < 256; i++) {
    S[i] = i;
}
// ... key scheduling and PRGA
```

## Analysis Workflow

### 1. Initial Assessment
- Import/export analysis
- find entry point then human code 

### 2. Deep Analysis
- Disassembly and decompilation
- Function analysis
- Control flow analysis
- Cross-reference analysis

### 3. Behavioral Analysis
- API call analysis
- Network communication analysis
- File system operations
- Registry modifications

### 4. Anti-Analysis Detection
- Debugger detection
- VM detection
- Code obfuscation analysis
- Packing detection

### 5. Documentation
- Function mapping
- Behavior documentation
- IOC extraction
- Report generation

## Tools and Resources

**Scripts and Automation:**
- IDAPython scripts
- Radare2 scripts
- Ghidra scripts
- Custom analysis tools
